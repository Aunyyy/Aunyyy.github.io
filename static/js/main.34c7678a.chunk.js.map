{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/Switch/Switch.jsx","Algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","_this$props","isEnd","isStart","isBlock","isHeavyTraffic","isModerateTraffic","isLightTraffic","isVisited","col","row","onMouseDown","onMouseEnter","onMouseUp","type","react_default","a","createElement","id","concat","className","Component","Switch","isHeavyTrafficSwitch","isModerateTrafficSwitch","isLightTrafficSwitch","isToggled","onToggle","checked","onChange","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","_step2","nodes","_iterator2","_createForOfIteratorHelper","s","n","done","_step3","value","_iterator3","node","push","err","e","f","getAllNodes","length","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbours","sort","nodeA","nodeB","_step","_iterator","neighbours","filter","neighbour","getUnvisitedNeighbours","previousNode","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","heavyTrafficToggled","moderateTrafficToggled","lightTrafficToggled","initalState","PathfindingVisualizer","setStage","objectSpread","setState","moveNode","mouseIsPressed","newGrid","getNewGridWithTrafficToggled","_this$state","gridAfterNodesMoved","switchType","newSwitchRow","getNewSwitchRowToggled","switchRow","nodesInShortestPathOrder","nodesInShortedPathOrder","currentNode","unshift","shortestPathOrder","animateDijktras","_this2","_loop","i","setTimeout","document","getElementById","animateShortestPath","_loop2","_this3","_this$state2","Fragment","onClick","visualizeDijktra","clearScreen","map","switches","Switch_Switch_Switch","handleToggle","rowIdx","key","nodeIdx","Node_Node_Node","handleMouseDown","handleMouseEnter","handleMouseUp","createSwitch","createNode","Infinity","slice","newNode","newSwitch","otherSwitchesFalse","switchToSetFalse","currentRow","App","PathfindingVisualizer_PathfindingVisualizer_PathfindingVisualizer","reportWebVitals","onPerfEntry","Function","__webpack_require__","then","bind","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","src_App"],"mappings":"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","file":"static/js/main.34c7678a.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const \r\n        {\r\n            isEnd, \r\n            isStart,\r\n            isBlock,\r\n            isHeavyTraffic,\r\n            isModerateTraffic,\r\n            isLightTraffic,\r\n            isVisited,\r\n            col,\r\n            row,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        \r\n        } = this.props;\r\n\r\n        // The type of the node is determined using its boolean properties\r\n        const type = isEnd\r\n        ? \"node-finish\"\r\n        : isStart\r\n        ? \"node-start\"\r\n        : isBlock\r\n        ? \"node-block\"\r\n        : isHeavyTraffic\r\n        ? \"node-heavy-traffic\"\r\n        : isModerateTraffic\r\n        ? \"node-moderate-traffic\"\r\n        : isLightTraffic\r\n        ? \"node-light-traffic\"\r\n        : isVisited\r\n        ? \"node-visited\"\r\n        : \"\";\r\n        return (\r\n        <div \r\n        // The id of the node is in the form node-row-col, exaple: node-4-5\r\n        id={`node-${row}-${col}`}\r\n        //The type is added as a class name so that css can be performed on it\r\n        className={`node ${type}`}\r\n        //Handlers are added to the node\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n        ></div>);\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport \"./Switch.css\";\r\n\r\nexport default class Switch extends Component\r\n{\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const \r\n        {\r\n            isHeavyTrafficSwitch,\r\n            isModerateTrafficSwitch,\r\n            isLightTrafficSwitch,\r\n            isToggled,\r\n            onToggle,\r\n            \r\n        \r\n        } = this.props;\r\n\r\n        //Determines the type of switch using the boolean variables\r\n        const type = isHeavyTrafficSwitch\r\n        ? \"heavy-traffic\"\r\n        : isModerateTrafficSwitch\r\n        ? \"moderate-traffic\"\r\n        : isLightTrafficSwitch\r\n        ? \"light-traffic\"\r\n        : \"\";\r\n\r\n        return (\r\n            // The type is added infront of the class name so it can be singled out in css\r\n            <label className={`switch ${type}`}>\r\n                {/* The checkbox is cheecked on toggle and after any change the onToggle function is called */}\r\n                <input type=\"checkbox\" checked={isToggled} onChange={() => onToggle(isHeavyTrafficSwitch, isModerateTrafficSwitch, isLightTrafficSwitch)}/>\r\n                <div className='slider'/>\r\n            </label>);\r\n    }\r\n}","\r\n//Dijkstras function \r\nexport function dijkstra(grid, startNode, endNode) {\r\n    //Tracks the nodes the algorithm has visited\r\n    const visitedNodesInOrder = [];\r\n    //The start nodes distance is set to 0\r\n    startNode.distance = 0;\r\n    //All nodes on the grid are obtained\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    //While loop runs until all nodes have been reached \r\n    while (!!unvisitedNodes.length) {\r\n        //The next node to visit is sorted by distance in ascending order\r\n        sortNodesByDistance(unvisitedNodes);\r\n        //Hence, the closest node is the first element in the list\r\n        const closestNode = unvisitedNodes.shift();\r\n        //If a node is a block then the algorithm should skip the current iteration\r\n        if (closestNode.isBlock) continue;\r\n\r\n        //The closest nodes visited property is set to true\r\n        closestNode.isVisited = true;\r\n        //The closest node is appened into the visited node list\r\n        visitedNodesInOrder.push(closestNode);\r\n        //If we reach the end node then we return the visited node list\r\n        if (closestNode === endNode) return visitedNodesInOrder;\r\n        //if not we get the neighbours of the closest node.\r\n        updateUnvisitedNeighbours(closestNode, grid);\r\n    }\r\n}\r\n\r\n//Sorts the nodes so that the closest node is in the start\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n// Sets the distance of the unvisited neighbours of a node\r\n// and sets the previous node of the neighbours as the current node\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n    //Gets nighbours that have not been visited\r\n    const unvisitedNeighbours = getUnvisitedNeighbours(node, grid);\r\n    //Iterates through them\r\n    for (const neighbour of unvisitedNeighbours) {\r\n        //Setss their distance based on their type (normal, heavy traffic, moderate traffic and light traffic)\r\n        if (neighbour.isHeavyTraffic) neighbour.distance = node.distance + 15;\r\n        else if (neighbour.isModerateTraffic) neighbour.distance = node.distance + 10;\r\n        else if (neighbour.isLightTraffic) neighbour.distance = node.distance + 5;\r\n        else{\r\n        neighbour.distance = node.distance + 1;\r\n        }\r\n        //Sets their previous node as the current node\r\n        neighbour.previousNode = node;\r\n    }\r\n}\r\n\r\n//Gets the neighbours of a node (top, bottom, right, left)\r\n//and filters them by only returning those that have not been visited yet\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n    const neighbours = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbours.push(grid[row-1][col]);\r\n    if (row <grid.length - 1) neighbours.push(grid[row+1][col]);\r\n    if (col > 0) neighbours.push(grid[row][col-1]);\r\n    if (col < grid[0].length - 1) neighbours.push(grid[row][col+1]);\r\n    return neighbours.filter(neighbour => !neighbour.isVisited)\r\n}\r\n\r\n//Returns all nodes on the grid\r\nfunction getAllNodes(grid) {\r\n    const nodes = [];\r\n    //Iterates through the grid and returns a 2-d array\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            nodes.push(node);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\n// Backtracks from the end node to find the shortest path from the start node\r\nexport function shortestPathOrder(endNode) {\r\n    //Creates an empty list \r\n    const nodesInShortedPathOrder = [];\r\n    //Sets the current node to the end ndoe\r\n    let currentNode = endNode;\r\n\r\n    //This will stop at the start node since its previous node is null\r\n    while (currentNode !== null) {\r\n        //Adds the current node to the beginning of the list\r\n        nodesInShortedPathOrder.unshift(currentNode);\r\n        //Sets the current node to its previous node\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    //returns the list\r\n    return nodesInShortedPathOrder;\r\n}","//Importing dependencies\r\nimport React, { Component } from 'react'\r\nimport Node from \"./Node/Node\";\r\nimport Switch from \"./Switch/Switch\"\r\nimport { dijkstra, shortestPathOrder } from '../Algorithms/dijkstra';\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\n//Index of start and end node on 2-d grid\r\nlet START_NODE_ROW = 14;\r\nlet START_NODE_COL = 1;\r\nlet END_NODE_ROW = 4\r\nlet END_NODE_COL = 57;\r\n\r\n//Traffic Switches intially unactivated\r\nlet heavyTrafficToggled = false;\r\nlet moderateTrafficToggled = false;\r\nlet lightTrafficToggled = false;\r\n\r\n//Initialize state variable\r\nlet initalState = {};\r\n\r\nexport default class PathfindingVisualizer extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        setStage();\r\n        this.state = { ...initalState };\r\n    }\r\n    //Handler for mouse down event\r\n    handleMouseDown(row, col) {\r\n        const {grid} = this.state;\r\n        const node = grid[row][col];\r\n        // if the node selected is the start or end node move the node\r\n        if (node.isStart || node.isEnd) {\r\n            this.setState({ moveNode:node, mouseIsPressed: true});\r\n        }\r\n        // if not ...\r\n        else {\r\n            // ... then if any traffic switch is toggled return a grid with the node updated\r\n            if (heavyTrafficToggled || moderateTrafficToggled || lightTrafficToggled) {\r\n\r\n                // This grid will have the selected node represented by its respective traffic colour\r\n                //(heavy, moderate or light)\r\n                const newGrid = getNewGridWithTrafficToggled(this.state.grid, row, col);\r\n                //Set that grid as the state and set mouse presses to true\r\n                this.setState({grid: newGrid, mouseIsPressed: true});\r\n            }\r\n        }\r\n    }\r\n\r\n    // Handler for mouse enter event\r\n    handleMouseEnter(row, col) {\r\n        const {moveNode, grid, mouseIsPressed} = this.state;\r\n        // If the user selected the start or end node and the mouse is currently being pressed\r\n        // This is used to track when the mouse is being dragged\r\n        if (moveNode != null && mouseIsPressed) {\r\n            // Get a grid after the selected node has been moved from its starting position\r\n            const newGrid = gridAfterNodesMoved(grid, moveNode, row, col);\r\n            // Set the new grid as the state and change the moveNode to the current node.\r\n            this.setState({grid: newGrid, moveNode: newGrid[row][col]});\r\n        }\r\n        else{\r\n            // If the below conditions are not met do nothing\r\n            if (!mouseIsPressed || (!heavyTrafficToggled && !moderateTrafficToggled && !lightTrafficToggled)) return;\r\n            //Otherwise get a new grid with the selected node's traffic property has been toggled\r\n            const newGrid = getNewGridWithTrafficToggled(this.state.grid, row, col);\r\n            //set the new grid as the state\r\n            this.setState({grid: newGrid});\r\n        }\r\n    }\r\n\r\n    // Handler for mouse up event\r\n    handleMouseUp() {\r\n        //Set mouse pressed as false and moveNode as null\r\n        this.setState({mouseIsPressed: false, moveNode: null});\r\n    }\r\n\r\n    // Handler for switch toggle\r\n    handleToggle(isHeavyTrafficSwitch, isModerateTrafficSwitch, isLightTrafficSwitch) {\r\n        \r\n        // Check which switch has been toggled (0 = heavy, 1 = moderate, 2 = light)\r\n        let switchType = -1;\r\n        if (isHeavyTrafficSwitch){\r\n            switchType = 0;\r\n            heavyTrafficToggled = !heavyTrafficToggled;\r\n        }\r\n        else if(isModerateTrafficSwitch){\r\n            switchType = 1;\r\n            moderateTrafficToggled = !moderateTrafficToggled;\r\n        }\r\n        else if(isLightTrafficSwitch) {\r\n            switchType = 2;\r\n            lightTrafficToggled = !lightTrafficToggled;\r\n        }\r\n\r\n        //Get new switch row with the selected switch turned on\r\n        const newSwitchRow = getNewSwitchRowToggled(this.state.switchRow, switchType)\r\n\r\n        //Set this switch row as the state\r\n        this.setState({switchRow: newSwitchRow});\r\n    }\r\n\r\n    // Clear the screen\r\n    clearScreen() {\r\n        // Reset all properties on nodes and switches\r\n        setStage();\r\n        this.setState({ ...initalState });\r\n        heavyTrafficToggled = false;\r\n        moderateTrafficToggled = false;\r\n        lightTrafficToggled = false;\r\n    }\r\n\r\n    //Visualize the algorithm on screen\r\n    visualizeDijktra() {\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const endNode = grid[END_NODE_ROW][END_NODE_COL];\r\n\r\n        //Get the nodes visited by the dijkstra's algorithm\r\n        const visitedNodesInOrder = dijkstra(grid, startNode, endNode);\r\n        // Get the nodes representing the shortest path\r\n        const nodesInShortestPathOrder = shortestPathOrder(endNode);\r\n        // Call method to run animation\r\n        this.animateDijktras(visitedNodesInOrder, nodesInShortestPathOrder, grid);\r\n    }\r\n\r\n    // Animate the nodes on screen\r\n    animateDijktras(visitedNodesInOrder, nodesInShortestPathOrder, grid) {\r\n        //Iterate through the nodes visited by the algorithm\r\n        for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n\r\n            //Used to change the colour of the node to show the nodes visited\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n\r\n                //Instead of rendering elements every 10ms only their class name is changed for effieciency\r\n                \r\n                //Used to retain the colour by the start and end node\r\n                if (node.isStart){\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                \"node node-visited node-start\";\r\n                }\r\n                else if (node.isEnd){\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                \"node node-visited node-finish\";\r\n                }\r\n                // Every other node is coloured dark blue\r\n                else{\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                \"node node-visited\";\r\n                }\r\n\r\n                //At the end of the for loop, the shortest path is animated\r\n                if (i === visitedNodesInOrder.length - 1) {\r\n                    this.animateShortestPath(nodesInShortestPathOrder, grid);\r\n                }\r\n            }, 10 * i)\r\n        }\r\n    }\r\n\r\n    // Animate the shortest path on screen, exact same as animateDijktras method but with a different list (nodesInShortestPathOrder)\r\n    animateShortestPath(nodesInShortestPathOrder, grid) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                if (node.isStart){\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                \"node node-shortest-path node-start\";\r\n                }\r\n                else if (node.isEnd){\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                \"node node-shortest-path node-finish\";\r\n                }\r\n                else{\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    \"node node-shortest-path\";\r\n                }\r\n            }, 50 * i)\r\n        }\r\n        //Sets the current grid as the state\r\n        this.setState({ grid : grid});\r\n    }\r\n\r\n    //Renders elements on screen\r\n    render()\r\n    {\r\n        const {grid, switchRow, mouseIsPressed} = this.state;\r\n        return (\r\n            <>\r\n            {/* Button that calls visualizeDijktra method on click */}\r\n            <button onClick={() => this.visualizeDijktra()}>\r\n                Visualize Dijkra's Algorithm\r\n            </button>\r\n            {/* Button that clears the screen on click */}\r\n            <button onClick={() => this.clearScreen()}> \r\n                Clear\r\n            </button>\r\n            \r\n            {/* Div element for the traffic switches */}\r\n            <div className = \"switchRow\">\r\n                {/* Returns  switch element*/}\r\n                {switchRow.map((switches) => {\r\n                        const {isToggled, isHeavyTrafficSwitch, isModerateTrafficSwitch, isLightTrafficSwitch} = switches\r\n                        return(\r\n                            <Switch\r\n                            // Sets properties\r\n                                isToggled={isToggled}\r\n                                isHeavyTrafficSwitch={isHeavyTrafficSwitch}\r\n                                isModerateTrafficSwitch={isModerateTrafficSwitch}\r\n                                isLightTrafficSwitch={isLightTrafficSwitch}\r\n                                onToggle={(isHeavyTrafficSwitch, isModerateTrafficSwitch, isLightTrafficSwitch) => this.handleToggle(isHeavyTrafficSwitch, isModerateTrafficSwitch, isLightTrafficSwitch)}\r\n                            ></Switch>\r\n                        );\r\n                })}\r\n            </div>\r\n            <div className = \"grid\">\r\n            {grid.map((row, rowIdx) => {\r\n                // Returns the grid\r\n                    return (\r\n                        <div className = \"row\" key={rowIdx}>\r\n                            {/* Returns node element */}\r\n                            {row.map((node, nodeIdx) => {\r\n                                const {row, col, isStart, isEnd, isBlock, isVisited, isHeavyTraffic, isModerateTraffic, isLightTraffic} = node;\r\n                                return (\r\n                                <Node\r\n                                // Sets properties\r\n                                    key={nodeIdx}\r\n                                    col={col}\r\n                                    row={row}\r\n                                    isStart ={isStart}\r\n                                    isEnd={isEnd}\r\n                                    isBlock={isBlock}\r\n                                    isVisited={isVisited}\r\n                                    isHeavyTraffic={isHeavyTraffic}\r\n                                    isModerateTraffic={isModerateTraffic}\r\n                                    isLightTraffic={isLightTraffic}\r\n                                    mouseIsPressed={mouseIsPressed}\r\n                                    onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                    onMouseEnter={(row, col) =>  this.handleMouseEnter(row, col)}\r\n                                    onMouseUp={() => this.handleMouseUp()}\r\n                                ></Node>\r\n                                );\r\n                            })}\r\n                        </div>\r\n                    );\r\n                })}\r\n            </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\n// Creates properties used by a switch\r\nconst createSwitch = (switchType) => {\r\n    return {\r\n        //If the switch type is 0 it is a heavy traffic switch\r\n        isHeavyTrafficSwitch: switchType === 0,\r\n        //If 1 it is a moderate traffic switch\r\n        isModerateTrafficSwitch: switchType === 1,\r\n        //If 2 it is a light traffic switch\r\n        isLightTrafficSwitch: switchType === 2,\r\n        //Toggled is initially set to false\r\n        isToggled: false,\r\n    }\r\n}\r\n// Creates properties used by a node\r\nconst createNode = (col, row) => {\r\n    return {\r\n        col,\r\n        row,\r\n        // Every node is a block unless its is the fifth in the sequence\r\n        isBlock: row % 5 !== 4 && col % 5 !== 4,\r\n\r\n        //If the row and column match the start node row and start node column\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n\r\n        //If the row and column match the end node row and end node column\r\n        isEnd: row === END_NODE_ROW && col === END_NODE_COL,\r\n\r\n        isHeavyTraffic: false,\r\n        isModerateTraffic: false,\r\n        isLightTraffic: false,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        previousNode: null,\r\n    }\r\n}\r\n\r\n// Returns a grid where the selected node is turned into a heavy, moderate or light traffic node\r\nconst getNewGridWithTrafficToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    let newNode = null;\r\n    if (heavyTrafficToggled)\r\n    {\r\n        newNode = {\r\n            ...node,\r\n            isHeavyTraffic: !node.isHeavyTraffic,\r\n        };\r\n    }\r\n    else if (moderateTrafficToggled)\r\n    {\r\n        newNode = {\r\n            ...node,\r\n            isModerateTraffic: !node.isModerateTraffic,\r\n        };\r\n    }\r\n    else if (lightTrafficToggled)\r\n    {\r\n        newNode = {\r\n            ...node,\r\n            isLightTraffic: !node.isLightTraffic,\r\n        };\r\n    }\r\n    //Replaces the old node with the newNode with updated properties\r\n    newGrid[row][col] = newNode;\r\n    //returns the updates grid\r\n    return newGrid;\r\n}\r\n\r\n//Returns a grid with the start or end node in a different position\r\nconst gridAfterNodesMoved = (grid, moveNode, row, col)  => {\r\n    const newGrid = grid.slice();\r\n    let newNode = newGrid[row][col];\r\n    //If the node to move is the start node then...\r\n    if (moveNode.isStart){\r\n        //... change the start node row and column to the new nodes row and col number\r\n        START_NODE_ROW = row;\r\n        START_NODE_COL = col;\r\n\r\n        //Change the isStart property from the previous node to the current node \r\n        moveNode = {\r\n            ...moveNode,\r\n            isStart: false,\r\n        };\r\n\r\n        newNode = {\r\n            ...newNode,\r\n            isStart: true,\r\n        }\r\n    }\r\n    //If it is not a start node then it must be an end node\r\n    else {\r\n        // Updates the row and col variables\r\n        END_NODE_ROW = row;\r\n        END_NODE_COL = col;\r\n\r\n        //Updates isEnd property from previous to current node\r\n        moveNode = {\r\n            ...moveNode,\r\n            isEnd: false,\r\n        };\r\n\r\n        newNode = {\r\n            ...newNode,\r\n            isEnd: true,\r\n        }\r\n    }\r\n    //Updates and returns the grid\r\n    newGrid[row][col] = newNode;\r\n    newGrid[moveNode.row][moveNode.col] = moveNode;\r\n    return newGrid;\r\n}\r\n\r\n//Returns a switchRow with traffic buttons toggled\r\nconst getNewSwitchRowToggled = (switchRow, switchType) => {\r\n    const newSwitchRow = switchRow.slice();\r\n    const switches = switchRow[switchType];\r\n    const newSwitch = {\r\n        ...switches,\r\n        isToggled: !switches.isToggled,\r\n    };\r\n    newSwitchRow[switchType] = newSwitch;\r\n\r\n    //Following code only allows 1 toggle to be active at a time\r\n    if (switchType === 0) {\r\n        newSwitchRow[1] = otherSwitchesFalse(1, switchRow);\r\n        newSwitchRow[2] = otherSwitchesFalse(2, switchRow);\r\n        moderateTrafficToggled = false;\r\n        lightTrafficToggled = false;\r\n    }\r\n    else if (switchType === 1) {\r\n        newSwitchRow[0] = otherSwitchesFalse(0, switchRow);\r\n        newSwitchRow[2] = otherSwitchesFalse(2, switchRow);\r\n        heavyTrafficToggled = false;\r\n        lightTrafficToggled = false;\r\n    }\r\n    else if (switchType === 2) {\r\n        newSwitchRow[0] = otherSwitchesFalse(0, switchRow);\r\n        newSwitchRow[1] = otherSwitchesFalse(1, switchRow);\r\n        heavyTrafficToggled = false;\r\n        moderateTrafficToggled = false;\r\n    }\r\n    //Returns the new row of switches\r\n    return newSwitchRow;\r\n}\r\n\r\n//Function to toggle off a switch\r\nconst otherSwitchesFalse = (switchToSetFalse, switchRow)  => {\r\n    const switches = switchRow[switchToSetFalse];\r\n    const newSwitch = {\r\n        ...switches,\r\n        isToggled: false,\r\n    };\r\n    return newSwitch\r\n}\r\n\r\n//Builds the stage by creating the grid, switchRow and sets that in the intialState variable\r\nconst setStage = () => {\r\n    const grid = [];\r\n    const switchRow = [];\r\n    for (let row = 0; row < 24; row++) {\r\n        const currentRow = [];\r\n        for(let col = 0; col < 59; col++) {\r\n            currentRow.push(createNode(col, row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    for(let switchType = 0; switchType < 3; switchType++) {\r\n        switchRow.push(createSwitch(switchType));\r\n    }\r\n\r\n    initalState = {\r\n        grid: grid,\r\n        switchRow: switchRow,\r\n        mouseIsPressed: false,\r\n        moveNode: null}\r\n}\r\n","import './App.css';\nimport React from 'react';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}